using System.Collections;
using System.Collections.Generic;
using CrazyMinnow.SALSA;
using UnityEngine;
using UnityEngine.Video;




public class AppManager : MonoBehaviour
{
    // The one and only instance of this class
    public static AppManager Instance { get; private set; }



    // A list of feedbacks imported from a json
    FeedbackList feedbackListItems;
    string activeFeedbackTitle;
    // Feedback resources and interpreters
    string audioClipPath = "Audio/ah_cest_horrible";
    private AudioSource audioSource;
    string videoClipPath = "Video/ah_cest_horrible";
    public VideoPlayer player;
    string openFacePath = "OpenFace/ah_cest_horrible";
    // A .csv file generated by OpenFace. Should include AU's, Pose and Gaze ONLY!!!
    public TextAsset actionUnitData;
    // A list of structures imported from a .csv file containing data frame by frame
    List<Frame> frames = new List<Frame>();



    // Game Objects manipulated by the script
    public Transform Camera;
    public Transform activeAvatar;
    public GameObject[] avatars;
    Transform headBone;
    SkinnedMeshRenderer[] smRenderers = new SkinnedMeshRenderer[2];
    AudioSource voice;
    // Eyes object in SALSA
    Eyes eyes;
    [SerializeField] BlendshapeAnimator blendshapeAnimator;
    [SerializeField] FeedbackRecorder feedbackRecorder;
    public AnimParam parameters;


    // Videoplayer related variables
    float time = 0f;
    bool isFeedbackPlayed = false;
    int frameIndex = 0;
    // A flag of sync with the example video affected by the UI
    bool vidSync = true;



    //bool isFeedbackRecorded = false;



    // A list of getters for other scripts
    public Transform GetCamera() { return Camera; }
    public SkinnedMeshRenderer[] GetSMRenderers() { return smRenderers; }
    public Transform GetHeadBone() { return headBone; }
    public Frame getFirstFrame() { return frames[0]; }
    public FeedbackList GetFeedbackList() { return feedbackListItems; }


    // Salsa lip-sync getter/setter
    public bool GetEyeAnimsEnabled()
    {
        return eyes.blinkEnabled || eyes.eyeEnabled; // true if any is enabled
    }
    public void SetEyeAnimsEnabled(bool status)
    {
        eyes.EnableEyelidBlink(status);
        eyes.EnableEye(status);
    }

    
    // Functions affected by UI
    public void ToggleVidSync(bool value)
    {
        vidSync = value;
    }
    public void LoadFeedbackRessources(int feedbackID)
    {
        activeFeedbackTitle = feedbackListItems.elements[feedbackID].name;


        audioClipPath = feedbackListItems.elements[feedbackID].path_Audio;
        audioSource = GetComponent<AudioSource>();
        AudioClip audioClip = Resources.Load<AudioClip>(audioClipPath);

        if (audioClip != null)
        {
            // Set the loaded audio clip to the AudioSource
            audioSource.clip = audioClip;

        }
        else
        {
            Debug.LogError("Failed to load audio clip from Resources folder: " + audioClipPath);
        }


        videoClipPath = feedbackListItems.elements[feedbackID].path_Video;
        VideoClip videoClip = Resources.Load<VideoClip>(videoClipPath);

        if (videoClip != null)
        {
            // Set the loaded video clip to the VideoPlayer
            player.clip = videoClip;

        }
        else
        {
            Debug.LogError("Failed to load video clip from Resources folder: " + videoClipPath);
        }

        openFacePath = feedbackListItems.elements[feedbackID].path_OpenFace;
        actionUnitData = Resources.Load<TextAsset>(openFacePath);
        frames = CsvImporter.ParseCSV(actionUnitData);
        blendshapeAnimator.SetFeedback();

        if (actionUnitData == null)
        {
            Debug.LogError("Failed to load OpenFace csv from Resources folder: " + openFacePath);
        } 
        // A temporary solution for video not playing for the first time due to some file format error
        else
        {
            PlayFeedback();
        }
        
    }


    // Avatar-related functions
    public void SetAvatarProps()
    {
        headBone = activeAvatar.Find("CC_Base_BoneRoot").GetChild(0).GetChild(1).GetChild(0).GetChild(0).GetChild(2).GetChild(0).GetChild(0);


        smRenderers[0] = activeAvatar.Find("Brows").GetComponent<SkinnedMeshRenderer>();
        smRenderers[1] = activeAvatar.Find("CC_Base_Body").GetComponent<SkinnedMeshRenderer>();
        //smRenderers[2] = activeAvatar.GetChild(0).Find("Brows_Extracted0").GetComponent<SkinnedMeshRenderer>();

        eyes = activeAvatar.GetComponent<Eyes>();
    }
    public void ChangeActiveAvatar(int value)
    {
        for (int i = 0; i < avatars.Length; i++)
        {
            if (i == value)
            {
                avatars[i].SetActive(true);
            }
            else
            {
                avatars[i].SetActive(false);
            }
        }

        activeAvatar = avatars[value].transform;
        SetAvatarProps();
        blendshapeAnimator.SetAvatarProps();
    }


    // Feedback playback functions
    public void PlayFeedback()
    {
        // Check if the VideoPlayer component is attributed
        if (vidSync && player != null)
        {
            // Prepare and play the video assigned to the VideoPlayer component only then play the avatar's animation
            player.Prepare();
            if (player.isPrepared)
            {

                player.Play();

                isFeedbackPlayed = true;

                voice.Play();
            }

        }
        else
        {
            //if there's no VideoPlayer assigned, the animation is good on its own
            isFeedbackPlayed = true;

            voice.Play();
        }
    }
    public void PlayFeedbackUpdate()
    {
        if (vidSync && player != null)
        {

            if ((int)player.frame > -1)
            {
                if ((int)player.frame < frames.Count - 1)
                {
                    blendshapeAnimator.PrepareFExpression(time, frames[(int)player.frame], frames[(int)player.frame + 1]);

                    // set back animation time if VideoPlayer lags behind
                    if (time > player.time + 0.04 || time < player.time)
                        time = frames[(int)player.frame].timestamp;

                }
                else if ((int)player.frame == frames.Count - 1)
                {
                    blendshapeAnimator.PrepareFExpression(time, frames[(int)player.frame], frames[(int)player.frame]);

                    // reset values after the video ends
                    ResetPlayFeedback();
                }

            }

        }
        else
        {

            if (frameIndex < frames.Count - 1)
            {

                blendshapeAnimator.PrepareFExpression(time, frames[frameIndex], frames[frameIndex + 1]);

            }
            // case for the last frame
            else if (frameIndex == frames.Count - 1)
            {

                blendshapeAnimator.PrepareFExpression(time, frames[frameIndex], frames[frameIndex]);

                // reset values after the video ends
                ResetPlayFeedback();
            }

            if (time > frames[frameIndex].timestamp)
            {
                frameIndex++;
            }



        }

        // time is unstoppable
        time += Time.deltaTime;

        //bsIndex = smRenderers[1].sharedMesh.GetBlendShapeIndex("Mouth_Smile_L");
        //Debug.Log("frame " + frames[frameIndex].frame + " | time " + time + " | timestamp " + frames[frameIndex].timestamp + " | AU " + frames[frameIndex].AU12_r + " | BS " + smRenderers[1].GetBlendShapeWeight(bsIndex));
    }
    public void ResetPlayFeedback()
    {
        isFeedbackPlayed = false;
        Instance.SetEyeAnimsEnabled(true);
        frameIndex = 0;
        time = 0f;

        if (feedbackRecorder.m_RecorderController.IsRecording())
        {
            StartCoroutine(RecordStopDelay(1));
        }
    }


    // Feedback video recorder functions
    IEnumerator FeedbackPlayDelay(float delay)
    {

        //yield on a new YieldInstruction that waits for 1 seconds.
        yield return new WaitForSeconds(delay);
        PlayFeedback();

    }
    public void RecordFeedback()
    {
        feedbackRecorder.RecorderStart(activeFeedbackTitle);
        StartCoroutine(FeedbackPlayDelay(1));
        
    }
    IEnumerator RecordStopDelay(float delay)
    {

        //yield on a new YieldInstruction that waits for [delay] seconds.
        yield return new WaitForSeconds(delay);
        feedbackRecorder.RecorderStop();

    }
    IEnumerator RecordAllFeedbackDelay(float delay)
    {

        foreach (FeedbackElement feedbackElement in feedbackListItems.elements)
        {
            LoadFeedbackRessources(feedbackElement.id);
            RecordFeedback();
            while (feedbackRecorder.m_RecorderController.IsRecording())
            {
                yield return new WaitForSeconds(delay);
            }
        }


    }
    public void RecordAllFeedback()
    {
        StartCoroutine(RecordAllFeedbackDelay(0.1f));
    }






    private void Awake()
    {
        // If there is an instance, and it's not me, delete myself.

        if (Instance != null && Instance != this)
        {
            Destroy(this);
        }
        else
        {
            Instance = this;
        }

        feedbackListItems = JsonImporter.ParseJSON();
    }
    
    // Start is called before the first frame update
    void Start()
    {
        SetAvatarProps();

        voice = GetComponent<AudioSource>();

        frames = CsvImporter.ParseCSV(actionUnitData);

        LoadFeedbackRessources(1);
    }

    // Update is called once per frame
    void Update()
    {
        // Check if a feedback is played
        if (isFeedbackPlayed)
        {
            PlayFeedbackUpdate();
        }



        //if (feedbackRecorder.readyToPlay)
        //{
        //    PlayFeedback();
        //}
    }


}
